package app

import (
	"context"
	"errors"
	"fmt"
	"net"
	"net/http"
	"strconv"

	"production-snippets/internal/config"
	"production-snippets/internal/data"
	"production-snippets/internal/logging"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/rs/cors"
	_ "github.com/swaggo/http-swagger/example/go-chi/docs" // docs is generated by Swag CLI, you have to import it.
	httpSwagger "github.com/swaggo/http-swagger/v2"
	"golang.org/x/sync/errgroup"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

// Create app struct
type App struct {
	cfg        *config.Config
	logger     *logging.Logger
	router     *chi.Mux
	httpServer *http.Server
	models     data.Models
}

// Run server througth errgroup
func (a *App) Run(ctx context.Context) error {
	grp, ctx := errgroup.WithContext(ctx)
	grp.Go(func() error {
		return a.startHTTP(ctx)
	})

	a.logger.Info().Msg("app initialized and started")
	return grp.Wait()
}

func (a *App) startHTTP(ctx context.Context) error {
	a.logger.Info().Strs("HTTP", []string{a.cfg.HTTP.IP, strconv.Itoa(a.cfg.HTTP.Port)}).Msg("Start")
	var listener net.Listener

	listener, err := net.Listen("tcp", fmt.Sprintf("%s:%d", a.cfg.HTTP.IP, a.cfg.HTTP.Port))
	if err != nil {
		a.logger.Fatal().Msg("fail to crete listener")
	}

	// Configure CORS
	c := cors.New(cors.Options{
		AllowedMethods:     a.cfg.HTTP.CORS.AllowedMethods,
		AllowedOrigins:     a.cfg.HTTP.CORS.AllowedOrigins,
		AllowCredentials:   true,
		AllowedHeaders:     a.cfg.HTTP.CORS.AllowedHeaders,
		OptionsPassthrough: true,
		ExposedHeaders:     a.cfg.HTTP.CORS.AllowedHeaders,
		Debug: false,
	})

	handler := c.Handler(a.router)

	a.httpServer = &http.Server{
		Handler:      handler,
		WriteTimeout: 15 * time.Second,
		ReadTimeout:  15 * time.Second,
	}

	// Start server
	if err := a.httpServer.Serve(listener); err != nil {
		switch {
		case errors.Is(err, http.ErrServerClosed):
			a.logger.Warn().Msg("Server shutdown")
		default:
			a.logger.Fatal().Err(err)
		}

	}

	err = a.httpServer.Shutdown(ctx)
	if err != nil {
		a.logger.Fatal().Err(err)
	}

	return err
}

// Return new instance of app
func NewApp(config *config.Config, logger *logging.Logger) (App, error) {
	logger.Info().Msg("router initializing")
	router := chi.NewRouter()

	logger.Info().Msg("swager docs initializing")
	// Swagger handler
	router.Get("/swagger/*", httpSwagger.Handler(
		httpSwagger.URL("http://golang.fvds.ru:10000/swagger/doc.json"), //The url pointing to API definition
	))

	router.Get("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "hello")
	})

	db, err := openDB(config)
	if err != nil {
		logger.Fatal().AnErr("open DB connection error", err)
	}

	app := App{
		cfg:    config,
		logger: logger,
		router: router,
		models: data.NewModels(db),
	}

	products, err := app.models.Products.GetAll()
	if err != nil {
		return App{}, err
	}

	for _, product := range products {
		logger.Debug().Msgf("products = %v", product)
	}

	return app, nil
}

// The openDB() function returns a *gorm.DB
func openDB(cfg *config.Config) (*gorm.DB, error) {
	db, err := gorm.Open(postgres.Open(cfg.PostgreSQL.DSN), &gorm.Config{})

	if err != nil {
		return nil, err
	}

	return db, nil
}
